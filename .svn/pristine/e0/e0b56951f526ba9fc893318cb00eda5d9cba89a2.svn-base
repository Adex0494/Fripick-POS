import React, {useState, useEffect, useReducer, useContext} from 'react'
import { useTheme } from '@mui/material/styles'
import { getHttpResponse } from '../../api/helper';
import { paymentMethods, accountTypes } from '../../constants';
import { Context } from '../../store/context';

import MainPageBody from './mainPageBody';



  const MainPage = () => {
    const {providerId, userId, token, companies, setCompanies, setItbis, setSubTotal, setCompanyBranchId,
         selectedEmployee, setSelectedEmployee, benefits, setBenefits, companyAccountBenefits, setCompanyAccountBenefits, setToUseBenefits,
         setAmountToProcess, setCashOrCardValue} = useContext(Context)

    //To do: transform all these useState vars into a reducer
    const [filterProductInputValue, setFilterProductInputValue] = useState('')
    const [selectedProducts, setSelectedProducts] = useState([])
    const [users, setUsers] = useState([])
    const [catalogList, setCatalogList] = useState([])
    const [selectedCatalogIndex, setSelectedCatalogIndex] = useState(0)
    const [lastProductsOrdered, setlastProductsOrdered] = useState([])
    const theme = useTheme();
    const [goToComboPage, setGoToComboPage] = useState(false)
    const [selectedComboItem, setSelectedComboItem] = useState({})
    const [selectedCompany, setSelectedCompany] = useState({})
    const [catalogTypeId, setCatalogTypeId] = useState()
    const [catalogsCurrentDateTime, setCatalogsCurrentDateTime] = useState()
    const [initialTimeLeft, setInitialTimeLeft] = useState()
    const [timeLeft, setTimeLeft] = useState()
    const [categories, setCategories] = useState([])
    const [categoriesSelected, setCategoriesSelected] = useState({})
    const [alert, setAlert] = useState({open: false})
    const [isLoading, setIsLoading] = useState(false)
    const [openModal, setOpenModal] = useState(false)
    const [selectedLetter, setSelectedLetter] = useState()
    const [selectedAccountTypeId, setSelectedAccountTypeId] = useState(accountTypes.employee)
    const [selectedPaymentMethod, setSelectedPaymentMethod] = useState(paymentMethods.nomina)
    const [availableBalanceToday, setAvailableBalanceToday] = useState(0)
    const [openNotEnoughBalanceMessage, setOpenNotEnoughBalanceMessage] = useState(false)
    const [cartAlert, setCartAlert] = useState({function: null, text: null})

    // --------------------Logic to set timer and and update it ---------------------------

    const substractSecond = () => {
        if(timeLeft > 0) setTimeLeft(prevTime => prevTime - 1)
        else{
            setCatalogList([])
            setSelectedCatalogIndex(0)
            setCatalogTypeId()
        }
    }

    useEffect(() => {
        if (catalogsCurrentDateTime && catalogList[selectedCatalogIndex]?.dateTimeClose) {
            const secondsDifference = Math.floor((new Date(catalogList[selectedCatalogIndex].dateTimeClose) - new Date(catalogsCurrentDateTime)) / 1000)

            if (secondsDifference > 0) {
                setTimeLeft(secondsDifference)
                setInitialTimeLeft(secondsDifference)
            }
        }
      
      }, [catalogsCurrentDateTime, selectedCatalogIndex, catalogList]);

      useEffect(() => {
        let interval
        if (initialTimeLeft)
           interval = setInterval(() => {
                substractSecond()
            }, 1000);
        return () => clearInterval(interval);
      }, [initialTimeLeft])

      //Set available balance
      useEffect(() => {
        const thisBenefits = selectedAccountTypeId === accountTypes.employee ? benefits : selectedAccountTypeId === accountTypes.company ? companyAccountBenefits : null
        const balancesFound = thisBenefits?.benefits?.find(benefit => benefit.id === 1)?.balances 
        const thisAvailableBalanceToday = (balancesFound?.find(balance => balance.name === 'Balance Diario Disponible') || balancesFound?.find(balance => balance.name === 'Balance Disponible'))?.amount || 0
        setAvailableBalanceToday(thisAvailableBalanceToday)
    },
        [benefits, selectedAccountTypeId])

    const secondsToTimeString = (totalSeconds) => {
        if (totalSeconds <= 0 || isNaN(totalSeconds)) {
            return '00:00:00'
        }
        let hours = Math.floor(totalSeconds/3600)
        let minutes = Math.floor((totalSeconds - (hours * 3600)) / 60 ) 
        let seconds = totalSeconds - hours * 3600 - minutes * 60

        hours = hours < 10 ? `0${hours}` : hours
        minutes = minutes < 10 ? `0${minutes}` : minutes
        seconds = seconds < 10 ? `0${seconds}` : seconds

        return `${hours}:${minutes}:${seconds}`
    }



// ---------------------------- http requests -----------------------------------------------
    const defaultErrorMessage = 'Ocurrió un error buscando los datos'
    const defaultAlertDuration = 3000

    const httpResponseHelper = async (url)=> {
        const response = await getHttpResponse(url,token, userId)
        return response
    } 

    const fetchUsers = async (companyId) => {
        setIsLoading(true)
        try{
            const response = await httpResponseHelper(`company-service/company/${companyId}/users`)
            setUsers(response.data.users)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)
    }

    const fetchCategories = async (providerId) => {
        setIsLoading(true)
        try{
            const response = await httpResponseHelper(`category-service/provider/${providerId}/categories`)
            setCategories(response.data)
            const categoriesSelectedObj = {}
            response.data.forEach(category => categoriesSelectedObj[category.name] = false)
            setCategoriesSelected(categoriesSelectedObj)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)

    }


    const fetchCompaniesAndUsers = async (providerId) => {
        setIsLoading(true)
        try{
            const response = await httpResponseHelper(`company-service/provider/${providerId}/companies`)
            setCompanies(response.data)
            const selectedCompany = response.data[0]
            setSelectedCompany(selectedCompany)
            fetchUsers(selectedCompany.companyId)
            }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)
    }

    const fetchCatalogByUserId = async (userId, providerId) => {
        setIsLoading(true)
        try{
            const companyBranchresponse = await httpResponseHelper(`company-service/users/${userId}/company-branch`)
            setCompanyBranchId(companyBranchresponse.data.companyBranchId)
            const catalogResponse = await httpResponseHelper(`catalogPosService/provider/${providerId}/catalogs?companybranchid=${companyBranchresponse.data.companyBranchId}`)
            const catalogData = catalogResponse.data.catalogs
            if (catalogData.length === 0){
                setCatalogList([])
                setCatalogTypeId()
                setCatalogsCurrentDateTime()
            }
            else{
                setCatalogList(catalogData)
                setCatalogsCurrentDateTime(catalogResponse.data.currentDateTime)
                setSelectedCatalogIndex(0)
                setCatalogTypeId(catalogData[0].catalogTypeId)
            }
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)
    }

    const fetchUserBenefits = async (userId, catalogTypeId) => {
        try{
            const response = await httpResponseHelper(`benefitservice/user/${userId}/benefits?catalogTypeId=${catalogTypeId}&accountTypeId=1`)
            setBenefits(response.data)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
    }

    const fetchCompanyAccountBenefits = async (userId, catalogTypeId) => {
        try{
            const response = await httpResponseHelper(`benefitservice/user/${userId}/benefits?catalogTypeId=${catalogTypeId}&accountTypeId=2`)
            setCompanyAccountBenefits(response.data)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
    }

    const fetchLatestItems = async ( userId, providerId ) => {
        try{
            const response = await httpResponseHelper(`catalogPosService/provider/${providerId}/latest-items?userId=${userId}`)
            setlastProductsOrdered(response.data)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
    }


    useEffect(() =>{
        fetchCompaniesAndUsers(providerId)
        fetchCategories(providerId)
    }, [])

    useEffect(() => {
        if(selectedEmployee.id && catalogTypeId){
            fetchUserBenefits(selectedEmployee.id, catalogTypeId)
            if (selectedEmployee.companyAccount) {
                fetchCompanyAccountBenefits(selectedEmployee.id, catalogTypeId)
            }
        }
        else setBenefits()
    },[selectedEmployee.id, catalogTypeId])

    
// ---------------------------- Functions ------------------------------------------------------

    const setFilterProductInputValueHandler = (value) => {
        setSelectedLetter(null)
        setFilterProductInputValue(value)
    }

    const setSelectedLetterHandler = (letter) => {
        setFilterProductInputValue('')
        setSelectedLetter(letter)
    }

    const toggleCategory = (categoryName) => {
        setCategoriesSelected(previousCategoriesSelected => {
            const previousCategoriesSelectedCopy = {...previousCategoriesSelected}
            previousCategoriesSelectedCopy[categoryName] = !previousCategoriesSelectedCopy[categoryName]
            return previousCategoriesSelectedCopy
        })
    }

    const changeCatalogIndexHandler = (index) => {
        setSelectedCatalogIndex(index)
        setCatalogTypeId(catalogList[index].catalogTypeId)
    }

    const notEnoughBalanceHandler = () => {
        setOpenNotEnoughBalanceMessage(true)
        setTimeout(() => setOpenNotEnoughBalanceMessage(false), 3000)
      }

    // Calculate benefits to use and whether it is possible to have current selected products (split calculation)
    const benefitsCalculation = (thisSelectedProducts) => {
        const newTaxes = {}

        let newSubtotal = 0
        let canHaveProducts = true
        let thisAmountToProcess = 0
        let totalCashOrCardValue = 0 //total cash or card value when payment method is nomina
        let availableBalanceRemaining = availableBalanceToday

        const benefitsOrder = (selectedAccountTypeId === accountTypes.employee ? benefits : selectedAccountTypeId === accountTypes.company ? companyAccountBenefits : null)?.benefitsOrder?.filter(benefit => benefit.benefitType !== 'limiteDeCredito').sort((a,b) => a.order - b.order)
        const thisToUseBenefits = {}
        let currentBenefitsOrderIndex = 0

        thisSelectedProducts.forEach(product => {
            const currentProductSubtotal = product.price * product.quantity
            newSubtotal += currentProductSubtotal // set subtotal
            let accItbis = 0
            let currentProductItbis = 0

            if(product.taxTypes[0] * 1){ //logic to set taxes
                accItbis = newTaxes[`ITBIS (${product.taxTypes[0] * 1}%)`] || 0
                currentProductItbis = product.price * (product.taxTypes[0] || 0) * product.quantity/100
                accItbis += currentProductItbis
                newTaxes[`ITBIS (${product.taxTypes[0] * 1}%)`] = accItbis // set taxes
            }


            // Determine all benefits to use in each product and in total 
            let thisCurrentProductBenefits = 0
            let currentProductTotalRemaining = currentProductSubtotal + currentProductItbis
            if(benefitsOrder){

                for(let i = currentBenefitsOrderIndex; i < benefitsOrder.length; i++){
                    const currentBenefitOrder = benefitsOrder[i]

                    const currentBenefitOrderAmount = currentBenefitOrder.benefitType === 'subsidio' ? (currentBenefitOrder.subsidyDetail[0]?.amount || 0) : currentBenefitOrder.amount
                    if (!thisToUseBenefits[currentBenefitOrder.benefitType]) thisToUseBenefits[currentBenefitOrder.benefitType] = 0
                    const currentAvailableBenefitAmount = currentBenefitOrderAmount - (thisToUseBenefits[currentBenefitOrder.benefitType])

                    
                    if(currentAvailableBenefitAmount >= currentProductTotalRemaining){
                        thisCurrentProductBenefits += currentProductTotalRemaining
                        thisToUseBenefits[currentBenefitOrder.benefitType] += currentProductTotalRemaining
                        currentProductTotalRemaining = 0
                        break
                    }
 
                    if (currentAvailableBenefitAmount < currentProductTotalRemaining){
                        thisCurrentProductBenefits += currentAvailableBenefitAmount
                        thisToUseBenefits[currentBenefitOrder.benefitType] += currentAvailableBenefitAmount
                        currentProductTotalRemaining -= currentAvailableBenefitAmount 
                        currentBenefitsOrderIndex ++
                    }

                }
            }
            
            
            product.benefits = thisCurrentProductBenefits

            let currentProductAmountToProcess
            const employeeAndNominaCondition = selectedAccountTypeId === accountTypes.employee && selectedPaymentMethod === paymentMethods.nomina
            const thisIsCompanyAccount = selectedAccountTypeId === accountTypes.company

            if (thisIsCompanyAccount && currentProductTotalRemaining > availableBalanceRemaining){ //Return false if there is not enough balance in the company account
                canHaveProducts = false
                return
            }

            if (thisIsCompanyAccount || employeeAndNominaCondition){
                currentProductAmountToProcess = currentProductTotalRemaining <= availableBalanceRemaining ? currentProductTotalRemaining : availableBalanceRemaining
                thisAmountToProcess += currentProductAmountToProcess
                availableBalanceRemaining -= currentProductAmountToProcess
            }

            if (employeeAndNominaCondition){ // set cash or card value in product if payment method is nomina and it's an employee account
                
                product.cashOrCardValue = currentProductTotalRemaining - currentProductAmountToProcess
                totalCashOrCardValue += product.cashOrCardValue
            
            }else{

                if (selectedAccountTypeId === accountTypes.employee && (selectedPaymentMethod === paymentMethods.efectivo || selectedPaymentMethod === paymentMethods.tarjeta)){
                    product.cashOrCardValue = currentProductTotalRemaining
                    thisAmountToProcess += currentProductTotalRemaining
                }
                
            }
            
        })

        if (canHaveProducts){
            
            setSubTotal(newSubtotal)
            setItbis(newTaxes)
            setToUseBenefits(thisToUseBenefits)
            setCashOrCardValue(totalCashOrCardValue)
            setAmountToProcess(thisAmountToProcess)
        }else{
            notEnoughBalanceHandler()
        }
        return {
            canHaveProducts,
        }
    }

    const addProductToCart = (product) => {
        
        setSelectedProducts((prev) => {
            const selectedProductsCopy = prev.map(prod => {return {...prod}})
            const foundProductIndex = selectedProductsCopy.findIndex(prod => prod.id === product.id)
            
            if (foundProductIndex >= 0) {
                const foundProductCopy = {...selectedProductsCopy[foundProductIndex]}
                foundProductCopy.quantity++
                selectedProductsCopy[foundProductIndex] = foundProductCopy
            }else{
                product.quantity = 1
                product.cashOrCardValue = 0
                product.deliveryDate = catalogList[selectedCatalogIndex].deliveryDate
                product.deliveryTypeId = catalogList[selectedCatalogIndex].deliveryTypes[0].id
                product.orderReason = ''
                product.providerId = providerId
                product.sections = []
                product.userType = selectedAccountTypeId
                selectedProductsCopy.push(product)
            }

            const calculation = benefitsCalculation(selectedProductsCopy)
            if(calculation.canHaveProducts){
                return selectedProductsCopy
            }else{
                return prev
            }
        })
    }

    const editProductQuantity = (productId, quantity, isCombo) => {
        if (quantity < 0) return
        setSelectedProducts((prev) => {
            const selectedProductsCopy = prev.map(prod => {return {...prod}})
            const foundProductIndex = selectedProductsCopy.findIndex(prod => isCombo ? prod.key === productId : prod.id === productId)
            const foundProductCopy = {...selectedProductsCopy[foundProductIndex]}
            foundProductCopy.quantity = quantity
            selectedProductsCopy[foundProductIndex] = foundProductCopy

            const calculation = benefitsCalculation(selectedProductsCopy)
            if(calculation.canHaveProducts){
                return selectedProductsCopy
            }else{
                return prev
            }
        })
    }

    const handleZeroQuantity = () => {
        if (selectedProducts.some(product => product.quantity < 1)){
            setSelectedProducts((prev) => {
                const selectedProductsCopy = prev.map(prod => {return {...prod, quantity: prod.quantity < 1 ? '1' : prod.quantity}})
                const calculation = benefitsCalculation(selectedProductsCopy)
                if(calculation.canHaveProducts){
                    return selectedProductsCopy
                }else{
                    return prev
                }
            })
        }
    }

    const deleteProductCart = (productId) => {
        setSelectedProducts(prev => {
            const selectedProductsFilter = prev.map(prod => {return {...prod}}).filter(product => product.id !== productId) //copying and filtering
            const calculation = benefitsCalculation(selectedProductsFilter)
            if(calculation.canHaveProducts){
                return selectedProductsFilter
            }else{
                return prev
            }
        })
    }

    const deleteComboCart = (combo) => {
        setSelectedProducts(prev => {
            const selectedProductsFilter = prev.map(prod => {return {...prod}}).filter(product => { //copying and filtering
                if(!product.selectedProductIndexes) return true
                if(combo.id !== product.id) return true
                if(combo.selectedProductIndexes === product.selectedProductIndexes) return false
                return true
            }) 

            const calculation = benefitsCalculation(selectedProductsFilter)
            if(calculation.canHaveProducts){
                return selectedProductsFilter
            }else{
                return prev
            }
        })
    }

    const comboSelectedHandler = (comboItem) => {
        setGoToComboPage(true)
        setSelectedComboItem(comboItem)
    }


    const clearComboPage = () =>{
        setGoToComboPage(false)
    }

    
    const addComboToCart = (combo) => {  
        setSelectedProducts((prev) => {
            const selectedProductsCopy = prev.map(prod => {return {...prod}})
            let foundSameCombo = false
            const foundCombos = selectedProductsCopy.filter(thisCombo => combo.id === thisCombo.id)
            let foundCombo
            if (foundCombos.length > 0){
                for (let i=0; i<foundCombos.length; i++) 
                {
                    foundCombo = foundCombos[i]
                    if (foundCombo.sections?.length === combo.sections?.length){
                        foundSameCombo = true
                        foundCombo.sections.forEach(section => {
                            const sameSections = combo.sections.filter(thisSection => thisSection.id === section.id)
                            if (sameSections.length === 0){
                                foundSameCombo = false
                                return
                            }else if(!sameSections.some(sameSection => sameSection.variantId === section.variantId)){
                                foundSameCombo = false
                                return
                            }
                        })
                        if (foundSameCombo) break
                    }

                }

                if (foundSameCombo === true){
                    foundCombo.quantity++
                }
            }

            if (!foundSameCombo) {
                combo.cashOrCardValue = 0
                combo.deliveryDate = catalogList[selectedCatalogIndex].deliveryDate
                combo.deliveryTypeId = catalogList[selectedCatalogIndex].deliveryTypes[0].id
                combo.orderReason = ''
                combo.providerId = providerId
                combo.userType = selectedAccountTypeId
                combo.key = Date.now()

                selectedProductsCopy.push(combo)
            }

            const calculation = benefitsCalculation(selectedProductsCopy)
            if(calculation.canHaveProducts){
                return selectedProductsCopy
            }else{
                return prev
            }
        })
    }

    const addComboToCartHandler =(combo) => {
        addComboToCart(combo)
        setGoToComboPage(false)
    }

    const clearCart = () => {
        setSelectedProducts([])
        setSubTotal(0)
        setItbis({})
    }

    const commonClear = () => {
        clearCart()
        setCatalogList([])
        setCatalogsCurrentDateTime()
        setInitialTimeLeft()
        setTimeLeft()
        setSelectedCatalogIndex(0)
        setCatalogTypeId()
        setlastProductsOrdered([])
    }

    const clearSelectedEmployee = () => {
        commonClear()
        setSelectedEmployee({})
    }

    const changeCompanyHandler = (newValue) => {
        setSelectedCompany(newValue)
        commonClear()
        setSelectedEmployee({})
        setUsers([])
        fetchUsers(newValue.companyId)
    }

    const changeEmployeeHandler = (newValue) => {
        commonClear()
        setSelectedEmployee(newValue)
        fetchCatalogByUserId(newValue.id, providerId)
        fetchLatestItems(newValue.id, providerId)
    }
    
      const handleCloseAlert = (event, reason) => {
        if (reason === 'clickaway') {
          return;
        }
    
        setAlert({open: false})
      };

      const handleCloseCartAlert = () => {
        setCartAlert({function: null, text: null})
      }

      const changeAccountTypeHandler = (id) => {
        const theFunction = () => {
            if(id === accountTypes.company){
                setSelectedPaymentMethod(paymentMethods.nomina)
            }
            setSelectedAccountTypeId(id)
        }

            if (!selectedProducts || selectedProducts.length === 0) theFunction()
            else setCartAlert({function: () => {theFunction(); setCartAlert({function: null, text: null}); clearCart()},
                text: id === accountTypes.company ? 'Cuenta Empresa' : 'Nómina'
            })
      }

      const changePaymentMethodHandler = (value) => {
        const theFunction = () => {
            setSelectedPaymentMethod(value)
        }

        if (!selectedProducts || selectedProducts.length === 0) theFunction()
        else setCartAlert({function: () => {theFunction(); setCartAlert({function: null, text: null}); clearCart()},
            text: value === paymentMethods.nomina ? 'Nómina' : value === paymentMethods.efectivo ? 'Efectivo' : 'Tarjeta'
        })
      }

  
        return <MainPageBody filterProductInputValue={filterProductInputValue} selectedProducts={selectedProducts}
                companies={companies} users={users} lastProductsOrdered={lastProductsOrdered} theme={theme} goToComboPage={goToComboPage} selectedComboItem={selectedComboItem}
                selectedCompany={selectedCompany} addProductToCart={addProductToCart} 
                deleteComboCart={deleteComboCart} editProductQuantity={editProductQuantity} deleteProductCart={deleteProductCart} 
                comboSelectedHandler={comboSelectedHandler} clearComboPage={clearComboPage} addComboToCartHandler={addComboToCartHandler} changeCompanyHandler={changeCompanyHandler} 
                changeEmployeeHandler={changeEmployeeHandler} setFilterProductInputValue={setFilterProductInputValueHandler} benefits={benefits}
                companyAccountBenefits={companyAccountBenefits} selectedEmployee={selectedEmployee}
                catalogList={catalogList} selectedCatalogIndex={selectedCatalogIndex} setSelectedCatalogIndex={changeCatalogIndexHandler}
                timeLeft={ timeLeft ? secondsToTimeString(timeLeft) : '00:00:00'} categories={categories} categoriesSelected={categoriesSelected} toggleCategory={toggleCategory}
                alert={alert} handleCloseAlert={handleCloseAlert} setAlert={setAlert} isLoading={isLoading}
                openModal={openModal} setOpenModal={setOpenModal} selectedLetter={selectedLetter} setSelectedLetter={setSelectedLetterHandler} setSelectedAccountTypeId={changeAccountTypeHandler}
                selectedAccountTypeId={selectedAccountTypeId} selectedPaymentMethod={selectedPaymentMethod} setSelectedPaymentMethod={changePaymentMethodHandler}
                openNotEnoughBalanceMessage={openNotEnoughBalanceMessage}
                cartAlert={cartAlert} handleCloseCartAlert={handleCloseCartAlert} handleZeroQuantity={handleZeroQuantity} clearSelectedEmployee={clearSelectedEmployee}

        />

  }

  export default MainPage