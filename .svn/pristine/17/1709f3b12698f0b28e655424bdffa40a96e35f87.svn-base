import React, {useState, useEffect} from 'react'
import { useTheme } from '@mui/material/styles'
import { getHttpResponse } from '../../api/helper';

import MainPageBody from './mainPageBody';

const dummyProviderId = 839


  const MainPage = () => {
    const [filterProductInputValue, setFilterProductInputValue] = useState('')
    const [selectedProducts, setSelectedProducts] = useState([])
    const [itbis, setItbis] = useState(0)
    const [subTotal, setSubTotal] = useState(0)
    const [companies, setCompanies] = useState([])
    const [companyBranchId, setCompanyBranchId] = useState()
    const [users, setUsers] = useState([])
    // const [catalog, setCatalog] = useState([])
    const [catalogList, setCatalogList] = useState([])
    const [selectedCatalogIndex, setSelectedCatalogIndex] = useState(0)
    const [lastProductsOrdered, setlastProductsOrdered] = useState([])
    const theme = useTheme();
    const [goToComboPage, setGoToComboPage] = useState(false)
    const [selectedComboItem, setSelectedComboItem] = useState({})
    const [selectedCombos, setSelectedCombos] = useState([])
    const [selectedCompany, setSelectedCompany] = useState({})
    const [selectedEmployee, setSelectedEmployee] = useState({})
    const [catalogTypeId, setCatalogTypeId] = useState()
    const [benefits, setBenefits] = useState()
    const [companyAccountBenefits, setCompanyAccountBenefits] = useState()
    const [catalogsCurrentDateTime, setCatalogsCurrentDateTime] = useState()
    const [initialTimeLeft, setInitialTimeLeft] = useState()
    const [timeLeft, setTimeLeft] = useState()
    const [categories, setCategories] = useState([])
    const [categoriesSelected, setCategoriesSelected] = useState({})
    const [alert, setAlert] = useState({open: false})
    const [isLoading, setIsLoading] = useState(false)
    const [openModal, setOpenModal] = useState(false)
    const [selectedLetter, setSelectedLetter] = useState()
    const [selectedAccountTypeId, setSelectedAccountTypeId] = useState(1)

    // --------------------Logic to set timer and and update it ---------------------------

    const substractSecond = () => {
        if(timeLeft > 0) setTimeLeft(prevTime => prevTime - 1)
        else{
            setCatalogList([])
            setSelectedCatalogIndex(0)
            setCatalogTypeId()
        }
    }

    useEffect(() => {
        if (catalogsCurrentDateTime && catalogList[selectedCatalogIndex]?.dateTimeClose) {
            const secondsDifference = Math.floor((new Date(catalogList[selectedCatalogIndex].dateTimeClose) - new Date(catalogsCurrentDateTime)) / 1000)

            if (secondsDifference > 0) {
                setTimeLeft(secondsDifference)
                setInitialTimeLeft(secondsDifference)
            }
        }
      
      }, [catalogsCurrentDateTime, selectedCatalogIndex, catalogList]);

      useEffect(() => {
        let interval
        if (initialTimeLeft)
           interval = setInterval(() => {
                substractSecond()
            }, 1000);
        return () => clearInterval(interval);
      }, [initialTimeLeft])

    const secondsToTimeString = (totalSeconds) => {
        if (totalSeconds <= 0 || isNaN(totalSeconds)) {
            return '00:00:00'
        }
        let hours = Math.floor(totalSeconds/3600)
        let minutes = Math.floor((totalSeconds - (hours * 3600)) / 60 ) 
        let seconds = totalSeconds - hours * 3600 - minutes * 60

        hours = hours < 10 ? `0${hours}` : hours
        minutes = minutes < 10 ? `0${minutes}` : minutes
        seconds = seconds < 10 ? `0${seconds}` : seconds

        return `${hours}:${minutes}:${seconds}`
    }



// ---------------------------- http requests -----------------------------------------------
    const defaultErrorMessage = 'OcurriÃ³ un error buscando los datos'
    const defaultAlertDuration = 3000

    const fetchUsers = async (companyId) => {
        setIsLoading(true)
        try{
            const response = await getHttpResponse(`company-service/company/${companyId}/users`)
            setUsers(response.data.users)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)
    }

    const fetchCategories = async (providerId) => {
        setIsLoading(true)
        try{
            const response = await getHttpResponse(`category-service/provider/${providerId}/categories`)
            setCategories(response.data)
            const categoriesSelectedObj = {}
            response.data.forEach(category => categoriesSelectedObj[category.name] = false)
            setCategoriesSelected(categoriesSelectedObj)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)

    }


    const fetchCompaniesAndUsers = async (providerId) => {
        setIsLoading(true)
        try{
            const response = await getHttpResponse(`company-service/provider/${providerId}/companies`)
            setCompanies(response.data)
            const selectedCompany = response.data[0]
            setSelectedCompany(selectedCompany)
            fetchUsers(selectedCompany.companyId)
            }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)
    }

    const fetchCatalogByUserId = async (userId, providerId) => {
        setIsLoading(true)
        try{
            const companyBranchresponse = await getHttpResponse(`company-service/users/${userId}/company-branch`)
            setCompanyBranchId(companyBranchresponse.data.companyBranchId)
            const catalogResponse = await getHttpResponse(`catalogPosService/provider/${providerId}/catalogs?companybranchid=${companyBranchresponse.data.companyBranchId}`)
            const catalogData = catalogResponse.data.catalogs
            if (catalogData.length === 0){
                setCatalogList([])
                setCatalogTypeId()
                setCatalogsCurrentDateTime()
            }
            else{
                setCatalogList(catalogData)
                setCatalogsCurrentDateTime(catalogResponse.data.currentDateTime)
                setSelectedCatalogIndex(0)
                setCatalogTypeId(catalogData[0].catalogTypeId)
            }
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
        setIsLoading(false)
    }

    const fetchUserBenefits = async (userId, catalogTypeId) => {
        try{
            const response = await getHttpResponse(`benefitservice/user/${userId}/benefits?catalogTypeId=${catalogTypeId}&accountTypeId=1`)
            setBenefits(response.data)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
    }

    const fetchCompanyAccountBenefits = async (userId, catalogTypeId) => {
        try{
            const response = await getHttpResponse(`benefitservice/user/${userId}/benefits?catalogTypeId=${catalogTypeId}&accountTypeId=2`)
            setCompanyAccountBenefits(response.data)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
    }

    const fetchLatestItems = async ( userId, providerId ) => {
        try{
            const response = await getHttpResponse(`catalogPosService/provider/${providerId}/latest-items?userId=${userId}`)
            setlastProductsOrdered(response.data)
        }
        catch(error){
            setAlert({open: true, severity: 'error', message: error?.message || defaultErrorMessage, duration: defaultAlertDuration})
        }
    }


    useEffect(() =>{
        fetchCompaniesAndUsers(dummyProviderId)
        fetchCategories(dummyProviderId)
    }, [])

    useEffect(() => {
        if(selectedEmployee.id && catalogTypeId){
            fetchUserBenefits(selectedEmployee.id, catalogTypeId)
            if (selectedEmployee.companyAccount) {
                fetchCompanyAccountBenefits(selectedEmployee.id, catalogTypeId)
            }
        }
        else setBenefits()
    },[selectedEmployee.id, catalogTypeId])

    
// ---------------------------- Functions ------------------------------------------------------

    const setFilterProductInputValueHandler = (value) => {
        setSelectedLetter(null)
        setFilterProductInputValue(value)
    }

    const setSelectedLetterHandler = (letter) => {
        setFilterProductInputValue('')
        setSelectedLetter(letter)
    }

    const toggleCategory = (categoryName) => {
        setCategoriesSelected(previousCategoriesSelected => {
            const previousCategoriesSelectedCopy = {...previousCategoriesSelected}
            previousCategoriesSelectedCopy[categoryName] = !previousCategoriesSelectedCopy[categoryName]
            return previousCategoriesSelectedCopy
        })
    }

    const changeCatalogIndexHandler = (index) => {
        setSelectedCatalogIndex(index)
        setCatalogTypeId(catalogList[index].catalogTypeId)
    }

    const addProductToCart = (product) => {
        
        setSelectedProducts((prev) => {
            const selectedProductsCopy = [...prev]
            const foundProductIndex = selectedProductsCopy.findIndex(prod => prod.id === product.id)
            
            if (foundProductIndex >= 0) {
                const foundProductCopy = {...selectedProductsCopy[foundProductIndex]}
                foundProductCopy.quantity++
                selectedProductsCopy[foundProductIndex] = foundProductCopy
            }else{
                product.quantity = 1
                selectedProductsCopy.push(product)
            }
            setSubTotal(selectedProductsCopy.reduce((acc, current) => acc + current.price * current.quantity, 0))
            setItbis(selectedProductsCopy.reduce((acc, current) => acc + current.price * current.taxTypes[0] * current.quantity/100, 0))
            return selectedProductsCopy
        })
    }

    const editProductQuantity = (productId, quantity) => {
        if (quantity < 1) return
        setSelectedProducts((prev) => {
            const selectedProductsCopy = [...prev]
            const foundProductIndex = selectedProductsCopy.findIndex(prod => prod.id === productId)
            const foundProductCopy = {...selectedProductsCopy[foundProductIndex]}
            foundProductCopy.quantity = quantity
            selectedProductsCopy[foundProductIndex] = foundProductCopy
            setSubTotal(selectedProductsCopy.reduce((acc, current) => acc + current.price * current.quantity, 0))
            setItbis(selectedProductsCopy.reduce((acc, current) => acc + current.price * current.taxTypes[0] * current.quantity/100, 0))
            return selectedProductsCopy
        })
    }

    const deleteProductCart = (productId) => {
        setSelectedProducts(prev => {
            const selectedProductsFilter = prev.filter(product => product.id !== productId) 
            setSubTotal(selectedProductsFilter.reduce((acc, current) => acc + current.price * current.quantity, 0))
            setItbis(selectedProductsFilter.reduce((acc, current) => acc + current.price * current.taxTypes[0] * current.quantity/100, 0))
            return selectedProductsFilter 
        })
    }

    const deleteComboCart = (combo) => {
        setSelectedProducts(prev => {
            const selectedProductsFilter = prev.filter(product => {
                if(!product.selectedProductIndexes) return true
                if(combo.id !== product.id) return true
                if(combo.selectedProductIndexes === product.selectedProductIndexes) return false
                return true
            }) 
            setSubTotal(selectedProductsFilter.reduce((acc, current) => acc + current.price * current.quantity, 0))
            setItbis(selectedProductsFilter.reduce((acc, current) => acc + current.price * current.taxTypes[0] * current.quantity/100, 0))
            return selectedProductsFilter 
        })
    }

    const comboSelectedHandler = (comboItem) => {
        setGoToComboPage(true)
        setSelectedComboItem(comboItem)
    }


    const clearComboPage = () =>{
        setGoToComboPage(false)
    }

    
    const addComboToCart = (combo) => {
        
        setSelectedProducts((prev) => {
            const selectedProductsCopy = [...prev]
            selectedProductsCopy.push(combo)
            setSubTotal(selectedProductsCopy.reduce((acc, current) => acc + current.price * current.quantity, 0))
            setItbis(selectedProductsCopy.reduce((acc, current) => acc + current.price * current.taxTypes[0] * current.quantity/100, 0))
            return selectedProductsCopy
        })
    }

    const addComboToCartHandler =(combo) => {
        setSelectedCombos(prev =>{
            const newState = [...prev]
            newState.push(combo)
            return newState
        })

        addComboToCart(combo)
        setGoToComboPage(false)

    }

    const clearCart = () => {
        setSelectedProducts([])
        setSubTotal(0)
        setItbis(0)
    }

    const commonClear = () => {
        clearCart()
        setCatalogList([])
        setCatalogsCurrentDateTime()
        setInitialTimeLeft()
        setTimeLeft()
        setSelectedCatalogIndex(0)
        setCatalogTypeId()
        setlastProductsOrdered([])
    }

    const changeCompanyHandler = (newValue) => {
        setSelectedCompany(newValue)
        commonClear()
        setSelectedEmployee({})
        setUsers([])
        fetchUsers(newValue.companyId)
    }

    const changeEmployeeHandler = (newValue) => {
        commonClear()
        setSelectedEmployee(newValue)
        fetchCatalogByUserId(newValue.id, dummyProviderId)
        fetchLatestItems(newValue.id, dummyProviderId)
    }
    
      const handleCloseAlert = (event, reason) => {
        if (reason === 'clickaway') {
          return;
        }
    
        setAlert({open: false})
      };
  
        return <MainPageBody filterProductInputValue={filterProductInputValue} selectedProducts={selectedProducts} itbis={itbis} subTotal={subTotal}
                companies={companies} users={users} lastProductsOrdered={lastProductsOrdered} theme={theme} goToComboPage={goToComboPage} selectedComboItem={selectedComboItem}
                selectedCompany={selectedCompany} selectedEmployee={selectedEmployee} addProductToCart={addProductToCart} 
                deleteComboCart={deleteComboCart} editProductQuantity={editProductQuantity} deleteProductCart={deleteProductCart} 
                comboSelectedHandler={comboSelectedHandler} clearComboPage={clearComboPage} addComboToCartHandler={addComboToCartHandler} changeCompanyHandler={changeCompanyHandler} 
                changeEmployeeHandler={changeEmployeeHandler} setFilterProductInputValue={setFilterProductInputValueHandler} benefits={benefits}
                catalogList={catalogList} selectedCatalogIndex={selectedCatalogIndex} setSelectedCatalogIndex={changeCatalogIndexHandler}
                timeLeft={ timeLeft ? secondsToTimeString(timeLeft) : '00:00:00'} categories={categories} categoriesSelected={categoriesSelected} toggleCategory={toggleCategory}
                companyBranchId={companyBranchId} alert={alert} handleCloseAlert={handleCloseAlert} setAlert={setAlert} isLoading={isLoading}
                openModal={openModal} setOpenModal={setOpenModal} selectedLetter={selectedLetter} setSelectedLetter={setSelectedLetterHandler} setSelectedAccountTypeId={setSelectedAccountTypeId}
                selectedAccountTypeId={selectedAccountTypeId}
        />

  }

  export default MainPage